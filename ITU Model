# This is a sample Python script.

# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.
import math
import numpy as np
import subprocess

def distance (n, percent):
    # freq is a float number in MHz
    # n is the floor number, 1<= n <=3
    # percent is the device received signal strength
    # s_power is the source power in dbm
    # d_power is received device power in dbm
    # dis is the distance in meter
    freq = 5200.0 # in MHz
    s_power = -30
    d_power = (percent/2) - 100
    loss = s_power - d_power
    p_loss = p_loss_coef(freq/10**3)
    f_loss = floor_loss_coef(freq/10**3, n)

    loss += 28
    loss -= f_loss
    loss -= 20 * math.log10(freq)
    dis = 10**(loss/p_loss)

    return dis

def p_loss_coef (freq):
    # freq is a float number
    # return an integer
    coef = 0
    if (freq == 0.9):
        coef = 33
    elif ((freq>1.2) & (freq<1.3)):
        coef = 32
    elif ((freq>1.8) & (freq<2.0)):
        coef = 30
    elif (freq == 4.0):
        coef = 28
    elif (freq == 5.2):
        coef = 31
    elif (freq == 5.8):
        coef = 24
    elif (freq == 6.0):
        coef = 22
    else:
        print ("error: power loss coefficient unknown")

    return coef

def floor_loss_coef (freq, n):
    # freq is a float number
    # n is an integer, 1<= n <=3
    coef = 0
    if (n==0):
        return coef
    if (freq == 0.9):
        if (n==1):
            coef = 9
        elif (n==2):
            coef = 19
        elif (n==3):
            coef = 24
    elif ((freq>1.8) & (freq<2.0)):
        coef = 15 + 4*(n-1)
    elif (freq == 5.2 & n==1):
        coef = 16
    elif (freq == 5.8):
        if (n==1):
            coef = 22
        elif (n==2):
            coef = 28

    return coef

def trilateration(P1, P2, P3, r1, r2, r3):

  p1 = np.array([0, 0, 0])
  p2 = np.array([P2[0] - P1[0], P2[1] - P1[1], P2[2] - P1[2]])
  p3 = np.array([P3[0] - P1[0], P3[1] - P1[1], P3[2] - P1[2]])
  v1 = p2 - p1
  v2 = p3 - p1

  Xn = (v1)/np.linalg.norm(v1)

  tmp = np.cross(v1, v2)

  Zn = (tmp)/np.linalg.norm(tmp)

  Yn = np.cross(Xn, Zn)

  i = np.dot(Xn, v2)
  d = np.dot(Xn, v1)
  j = np.dot(Yn, v2)

  X = ((r1**2)-(r2**2)+(d**2))/(2*d)
  Y = (((r1**2)-(r3**2)+(i**2)+(j**2))/(2*j))-((i/j)*(X))
  Z1 = np.sqrt(max(0, r1**2-X**2-Y**2))
  Z2 = -Z1

  K1 = P1 + X * Xn + Y * Yn + Z1 * Zn
  K2 = P1 + X * Xn + Y * Yn + Z2 * Zn
  return K1,K2


command = "netsh wlan show networks mode=bssid"
ipconfig = subprocess.Popen(command, stdout=subprocess.PIPE)
ssid1 = 'drewphone'
ssid2 = 'dotingapple'
ssid3 = 'iPhone13'
ssid4 = 'bunger'
bssid = 'BSSID'
signal = b'Signal'
channel = b'Channel'
ssids = [dict() for x in range(4)]


command = "netsh wlan show networks mode=bssid"
ipconfig = subprocess.getoutput(command)
splitoutput = ipconfig.splitlines()
count = 0
for i in range(len(splitoutput)):
    if (ssid1 in splitoutput[i]) or (ssid2 in splitoutput[i]) or (ssid3 in splitoutput[i]) or (ssid4 in splitoutput[i]):
        ssids[count]["SSID"] = splitoutput[i].split()[3]
        ssids[count]["Signal"] = splitoutput[i + 5].split()[2]
        ssids[count]["Channel"] = splitoutput[i + 7].split()[2]
        count+=1



print(ssids[0])
print(ssids[1])
print(ssids[2])
print(ssids[3])

per0 = int(ssids[0]["Signal"].rstrip('%'))
per1 = int(ssids[1]["Signal"].rstrip('%'))
per2 = int(ssids[2]["Signal"].rstrip('%'))

p1 = (0, 0, 1)  # Coordinates of the first point
p2 = (5, 0, 0)  # Coordinates of the second point
p3 = (0, 10, 0)  # Coordinates of the third point
d1 = distance(0, per0)  # Distance from the first point to the target point
d2 = distance(0, per1)  # Distance from the second point to the target point
d3 = distance(0, per2)  # Distance from the third point to the target point

x, y= trilateration(p1, p2, p3, d1, d2, d3)
print("Computed Coordinates (x, y):", (x, y))
