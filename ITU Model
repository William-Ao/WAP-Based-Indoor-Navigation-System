# This is a sample Python script.

# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.
import math
import numpy as np


def distance (n, percent):
    # freq is a float number in MHz
    # n is the floor number, 1<= n <=3
    # percent is the device received signal strength
    # s_power is the source power in dbm
    # d_power is received device power in dbm
    # dis is the distance in meter
    freq = 5200.0 # in MHz
    s_power = -30
    d_power = (percent/2) - 100
    loss = s_power - d_power
    p_loss = p_loss_coef(freq/10**3)
    f_loss = floor_loss_coef(freq/10**3, n)

    loss += 28
    loss -= f_loss
    loss -= 20 * math.log10(freq)
    dis = 10**(loss/p_loss)

    return dis

def p_loss_coef (freq):
    # freq is a float number
    # return an integer
    coef = 0
    if (freq == 0.9):
        coef = 33
    elif ((freq>1.2) & (freq<1.3)):
        coef = 32
    elif ((freq>1.8) & (freq<2.0)):
        coef = 30
    elif (freq == 4.0):
        coef = 28
    elif (freq == 5.2):
        coef = 31
    elif (freq == 5.8):
        coef = 24
    elif (freq == 6.0):
        coef = 22
    else:
        print ("error: power loss coefficient unknown")

    return coef

def floor_loss_coef (freq, n):
    # freq is a float number
    # n is an integer, 1<= n <=3
    coef = 0
    if (n==0):
        return coef
    if (freq == 0.9):
        if (n==1):
            coef = 9
        elif (n==2):
            coef = 19
        elif (n==3):
            coef = 24
    elif ((freq>1.8) & (freq<2.0)):
        coef = 15 + 4*(n-1)
    elif (freq == 5.2 & n==1):
        coef = 16
    elif (freq == 5.8):
        if (n==1):
            coef = 22
        elif (n==2):
            coef = 28

    return coef

def trilateration(P1, P2, P3, r1, r2, r3):

  p1 = np.array([0, 0, 0])
  p2 = np.array([P2[0] - P1[0], P2[1] - P1[1], P2[2] - P1[2]])
  p3 = np.array([P3[0] - P1[0], P3[1] - P1[1], P3[2] - P1[2]])
  v1 = p2 - p1
  v2 = p3 - p1

  Xn = (v1)/np.linalg.norm(v1)

  tmp = np.cross(v1, v2)

  Zn = (tmp)/np.linalg.norm(tmp)

  Yn = np.cross(Xn, Zn)

  i = np.dot(Xn, v2)
  d = np.dot(Xn, v1)
  j = np.dot(Yn, v2)

  X = ((r1**2)-(r2**2)+(d**2))/(2*d)
  Y = (((r1**2)-(r3**2)+(i**2)+(j**2))/(2*j))-((i/j)*(X))
  Z1 = np.sqrt(max(0, r1**2-X**2-Y**2))
  Z2 = -Z1

  K1 = P1 + X * Xn + Y * Yn + Z1 * Zn
  K2 = P1 + X * Xn + Y * Yn + Z2 * Zn
  return K1,K2

# Example usage
p1 = (0, 0, 0)  # Coordinates of the first point
p2 = (3, 0, 0)  # Coordinates of the second point
p3 = (0, 4, 0)  # Coordinates of the third point
d1 = distance(0, 81)  # Distance from the first point to the target point
d2 = distance(0, 92)  # Distance from the second point to the target point
d3 = distance(0, 73)  # Distance from the third point to the target point

x, y= trilateration(p1, p2, p3, d1, d2, d3)
print("Computed Coordinates (x, y):", (x, y))
